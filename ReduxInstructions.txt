Redux Instructions
====
Step 0: 
  npm i redux react-redux 

  redux  - core redux framework 
  react-redux   -- patches up react with redux seamlessy 

Step 1: 
  In src/index.js Setup the the Redux Store here
  import { createStore } from 'redux'; 

Step 2: 
  Exec createStore() method and save it in a variable 
  const store = createStore(); //this needs a special argument called 'reducer'

Step 3:
  [Refer reducers/contactReducer.js]  Setup Reducer for the store
  // Reducer
  /*
  What's a Reducer?
    It is a function that takes the current state and 
    an action that was dispatched as it’s parameters and returns the new state.
  */

  // Setting up contactReducer so that
  // we can combine this reducer with other reducers later 
  // and make a big object for the store 
  // reducer should mandatorily return a state. 
  const contactReducer = (state = [], action) => { 
    // action.type will be there mandatorily 
    
    switch(action.type) {  
      case 'ADD_CONTACT':
        return state.concat([action.data]);
      default:
        return state;
    }
  }
  export default contactReducer;

Step 4: 
// work on combining all reducers for the entire app
// and have the following code 

//Step 4.1: Combining Reducers using Redux's combineReducers
import {combineReducers} from 'redux';

//Step 4.2 loading all reducers
import contactReducer from './contactReducer'; 

//Step 4.3 combine all reducers into one big object for store
const rootReducers = combineReducers({
  contacts: contactReducer
});

//Step 4.4 exporing the rootReducer -- that is the combined reducer
export default rootReducers;

==========

Step 5: in src/index.js, Setup reducer for the store
  //let’s import the combineReducer 
  //and pass it to the store as an argument.
  
  import rootReducers from './reducers'; 
  const store = createStore(rootReducers); 

========

Step 6: In src/index.js, inside the ReactDOM.render() block,
Provide the store data to the entire app 
  
  For the following to work.. 
  import { Provider } from 'react-redux'; 

  //Definition: The Provider component uses something 
    //called as React Context which allows you to pass the 
    //store object to any components 
    //that needs to access it without the need to pass props.
    //Provider should be imported from react-redux 
  
  ReactDOM.render(
    <React.StrictMode>
      <Provider store={store}>   { /* this is how we have to provide store data to the app */ }
        <App />
      </Provider>
    </React.StrictMode>
  ,
  document.getElementById('root')
);

=======


Step 7:
  create actions/types.js file for the various actions of the app's feature 
  have the following code in it.

  export const ADD_CONTACT = 'ADD_CONTACT';
  export const GET_CONTACTS = 'GET_CONTACTS';
  export const GET_CONTACT_BY_ID = 'GET_CONTACT_BY_ID';
  export const EDIT_CONTACT = 'EDIT_CONTACT';
  export const DELETE_CONTACT = 'DELETE_CONTACT';

====



Step 8:
  Have reducers/CONTACTReducer.js to have better switch case statement 
  with much more scalable code by using the action types 

  import { ADD_CONTACT, GET_CONTACTS, EDIT_CONTACT, DELETE_CONTACT } from "../actions/types";
    
  const CONTACTReducer = (state = [], action) => {
    // Step 8.1 
      //now it is time to understand the concept called 'Actions'
      //What are Actions? 
        //Actions are plain Javascript objects with a type property. 
        //This type property describes the event that is taking place 
        //in the application.
    switch(action.type) {
      case ADD_CONTACT:
        //Step 8.2 - clarification - of the following code, 
        //action.type = Event and action.data = Form Data from Add CONTACT
        return state.concat([action.data]);
      case GET_CONTACTS: 
        return state; // not implemented yet
      case GET_CONTACT_BY_ID: 
        return state; // not implemented yet
      case EDIT_CONTACT: 
        return state;  // not implemented yet
      case DELETE_CONTACT:
        return state.filter((CONTACT)=>CONTACT.id !== action.id);
      default:
        return state;
    }
  }

====


Step 9 & Step 10:
===
import React, { Component } from 'react';
// Step 10: 
import {connect} from 'react-redux';

//Step 9:
  // Almost  done... 
  // to dispatch action, let's write form submit logic 

class ContactForm extends Component {

  // Step 9.2 then, work on addContactHandler method 
  addContactHandler = (e) => {
    e.preventDefault();

    // making the payload ready
    const contactFormData = {
      name: this.getName.value,
      email: this.getEmail.value,
      phone: this.getPhone.value
    }

    console.log(contactFormData);
  }

  render() {
    return (
      // Step 9.1
      // form code can be  the following with ref's and submission logic 
      <div>
        <div className='container text-left'>
          <div className='row'>
            <div className='col-md-12'>
              <h3>Create Contact!</h3>
              <form onSubmit={this.addContactHandler}>
                <input required type="text"
                  placeholder="Enter Name"
                  className='form-control' 
                  ref={(input) => this.getName = input } /><br />
                <input required type="text"
                  placeholder="Enter EMail"
                  className='form-control'
                  ref={(input) => this.getEmail = input } /><br />

                <input required type="text"
                  placeholder="Enter Phone"
                  className='form-control'
                  ref={(input) => this.getPhone = input }/><br />
                <button className='btn btn-primary' 
                type='submit' 
              >Add Contact</button>
              </form>
            </div>
          </div>
        </div>
      </div>
    )
  }
}

// Step 10.1
//last line of the component should be the following. 
// after connecting props will be available in this component. 
export default connect()(ContactForm);

=========

Step11:
===
  It is time to dispatch events from form submission logic 
  // connect() helps props have dispatch method
  // using it we can dispatch action with type and data (payload)
  so, inside the addContactHandler logic, have a console.log(this.props);
  
  addContactHandler = (e) => {
    e.preventDefault();

    // making the payload ready
    const contactFormData = {
      name: this.getName.value,
      email: this.getEmail.value,
      phone: this.getPhone.value
    }

    console.log(contactFormData);

    console.log(this.props);  // Step 11: props exists because of connect method
    
  }
=====

Step12:
===
// Step 12  -- create services/contctService.js 
// ajax 
// api end point - http://jsonplaceholder.typicode.com/users
// http method -- POST
// payload - form data
// thru what tool? -- HTTPClient -- Axios

import axios from 'axios';
import { ADD_CONTACT } from "../actions/types";

const CONTACTS_API_URL = 'https://jsonplaceholder.typicode.com/users';

export const createContact = (data) => {
  console.log(data);
  return (dispatch) => {
    console.log(dispatch);
    return axios.post(CONTACTS_API_URL, data )
      .then(response => {
        console.log(dispatch);
          console.log('Submission SUCCESS');
          
      })
      .catch(error => {
          throw (error);
      })
      .finally( () => {
        console.log('Add Contact service call is over');
      }) 
  }
}

                      
==========
Step 13: 
  Dispatch the action in ContactForm.js submission logic

  import { createContact } from '../../services/contactService';

  // Step 9.2 then, work on addContactHandler method 
  addContactHandler = (e) => {
    e.preventDefault();

    // making the payload ready
    const contactFormData = {
      name: this.getName.value,
      email: this.getEmail.value,
      phone: this.getPhone.value
    }

    console.log(contactFormData);

    console.log(this.props);  // Step 11: props exists because of connect method
    // Step 13: dispatch method will be in the above props 
    this.props.dispatch(createContact( contactFormData )); // this is the service method
  }
=======

Step 14: 
  Check the error in console and fix it..
  The error says...
  Uncaught Error: Actions must be plain objects. 
  Use custom middleware for async actions.

  // Step 14.1
  install the following packages.
    npm i redux-logger redux-thunk
  
  // Step 14.2
  then, go to src/index.js 
    import logger from 'redux-logger'; // npm i redux-logger 
    import thunk from 'redux-thunk';  //npm i redux-thunk

  // step 14.3
  use redux-thunk middleware for async actions
    import { createStore, applyMiddleware } from 'redux';
  
    const store = createStore( rootReducers, applyMiddleware(thunk, logger) );

Step 15: 
=====
  in service, success logic have the following dispatch 

   dispatch({
      type: ADD_CONTACT,
      payload: {
        id: response.data.id,
        name: response.data.name,
        email: response.data.email,
        phone: response.data.phone
      }
    });

===
Step 16: 
  Check the app.. try creating a blog post.. it should work well. 
  we should be able to create a blog post.  (POST method is over)

  Create blog post operation is over. 
  Now, let's work on Listing Blog posts (Read operation)

====
Step 17: 
  in ContatList.js, let's get the state data from the store and 
  convert them into read-only props. 
  Redux's core purpose is to get rid of state across the app and make it props. 

  // Step 16.1
    import { connect } from 'react-redux';

  // Step 16.2
  to get the state and to convert that to props 
  in the ContatList.js file, make the following change in the export.

    export default connect(mapStateToProps)(PostList);
  
  //mapStateToProps() method should be defined in the same file before the export
  
    const mapStateToProps = (state) => {
      return {
          posts: state.posts
      }
    } 
  
  The above function will convert state to props for the PostList compoent.
  By doing the above this comp will no longer have state. 

====

Step 18:
====
  Now, let's think about getting all contacts on load 
  
  Note: 
  if the contacts list should be loaded for the home page to display...
  then, in src/index.js we have to write logic to load contacts at first.

    import { getContacts } from './services/contactsService';
    
    //To Setup Initial Loading -- for diplaying something at first load -- from rest api call
    store.dispatch(getContacts());

  ------ 
  But, our home page url should not show the all contacts. But contacts url.
  So, we have to now dispatch an action to getContacts in ContactList.js 
    import { getContacts } from './services/contactsService';

  Then, Inside the life cycle hook, 

    componentDidMount(){
      // send ajax calls to load all posts..
      // dispatch event 
      this.props.dispatch(getContacts());
    }



========
Step 19: 
----
Complete the logic in contactSetvice.js

// GET CONTACTS
export const getContacts = () => {
  // work with axios 
  return (dispatch) => {
    return axios.get(CONTACTS_API_URL )
      .then(response => {
        console.log(response);
        dispatch({
          type: GET_CONTACTS,
          payload: response.data
        })
      })
      .catch( (error) => {
         throw (error);
      })
      .finally( () => {
        console.log('It is over');
      })
  }
}

===

Step 20: 
----
After dispatching the action with type and payload, it will hit contactsReducer.js 
have the following logic there..

case GET_CONTACTS: 
      return action.payload; 

 Check the app! The app should display all posts on load. 
  Read operation is also over. (GET method)
===

Step 21: 
---
  


